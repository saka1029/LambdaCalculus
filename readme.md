# Javaによるラムダ計算の実装

このプログラムはJavaで
[ラムダ計算](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97)
を実装したものです。

## 文法

EBNFで記述した文法は以下のようになります。

```
式     = 因子 { 因子 }

因子   = 変数
       | 'λ' 変数 { 変数 } '.' 式
       | '(' 式 ')'
```

### 変数

変数は`λ`, `.`, `(`, `)'を除くすべての文字の並びです。

### ラムダ

[Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97)
に記述されている文法の内、ラムダ式の表記法を拡張しています。
通常のラムダ式は以下のように記述します。

```
λx y.x y
```

これは`x`と`y`を受け取って`x y` (`x`に`y`を適用する)を返す式です。

このプログラムではこれを以下のように表記することができます。

1. `λx.λy.x y` - カリー化（単一の引数に限定）した表記

`λ`はすべてのラムダ式をカリー化した場合のみ省略することができます。
`λ`を省略した場合、ラムダ式を構成する`.`は演算子と考えることができます。
これは右結合の演算子で、`x.y.x`は`x.(y.x)`と同じです。

### 適用

`t s` は`t`に`s`を適用することを表します。
これは関数`t(x)`に対して引数`s`を適用して呼び出すことに相当します。
適用は右結合の演算子と考えることができます。
そのため`x y z`は`(x y) z`と同じ意味になります。
`x.y.z.x y z`は`x.(y.(z.((x y) z)))`と同じです。

## コマンドラインからの実行

コマンドラインから実行する方法は以下のとおりです。

<pre><code>C:\Users\saka1029> <b>java -jar LambdaCalculus.jar</b>
% <b>(λx.x C) V</b>
V C
% <b>exit</b></code></pre>

プロンプト`% `に続けて
式をタイプするとそれを簡約して正規化した結果が表示されます。
`exit`とタイプするとプログラムは終了します。

### オプション

1. **-e** - 入力文字列をエコーします。
1. **-t** - トレースモードで動作します。
1. **-d** - ドット記法で出力します。


### 実行例

[チャーチ数](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97#.E8.87.AA.E7.84.B6.E6.95.B0.E3.81.A8.E7.AE.97.E8.A1.93)
は自然数をラムダ式として表現したものです。
Wikipediaの記述をそのままコマンドラインで実行すると以下のようになります。

    % define 0 λa b.b
    λ$0 $1.$1
    % define 1 λa b.a b
    λ$0.$0
    % define 2 λa b.a (a b)
    λ$0 $1.$0 ($0 $1)
    % define 3 λa b.a (a (a b))
    λ$0 $1.$0 ($0 ($0 $1))
    % define SUCC λn f x.f (n f x)
    λ$0 $1 $2.$1 ($0 $1 $2)
    % define PLUS λm n f.λx.m f (n f x)
    λ$0 $1 $2 $3.$0 $2 ($1 $2 $3)
    % define MULT λm n f.m (n f)
    λ$0 $1 $2.$0 ($1 $2)
    % SUCC 0
    λ$0.$0
    % SUCC (SUCC 1)
    λ$0 $1.$0 ($0 ($0 $1))
    % PLUS 2 3
    λ$0 $1.$0 ($0 ($0 ($0 ($0 $1))))
    % MULT 2 3
    λ$0 $1.$0 ($0 ($0 ($0 ($0 ($0 $1)))))
    % 
 
### 組み込みコマンド

* **exit**, **quit** - プログラムを終了します。

### 組み込み関数

* **`define V E`** - `E`を簡約した結果を自由変数`V`に設定します。 
* **`undefine V`** - 自由変数`V`を削除します。 
* **`trace on`** / **`trace off`** - トレース出力をon/offします。(初期値はoffです)
* **`dot on`** / **`dot off`** - ラムダ式の出力形式 ( `x.y.x` / `λx y.x` ) を切り替えます。(初期値はoffです)

## API

## 正規化

Term#equals()は字面で比較を行うので`λx.x`と`λy.y`は等しくなりません。
式としての等値性を調べる場合は、それぞれを正規化してから比較する必要があります。
正規化する場合はTerm#normalize()を使用します。

    Context c = defaultContext();
    Term xx = term("λx.x");
    Term yy = term("λy.y");
    assertNotEquals(yy, xx);
    assertEquals(yy.normalize(), xx.normalize());

`λx.x`や`λy.y`を正規化した結果はどちらも以下のようになります。

    λ$0.$0
    
式の先頭からみて束縛変数が出現する都度それを`$0`, `$1` ... に置換します。
冒頭で述べたように`$`を含む変数は使用できないので注意してください。
これはParserが`$`の使用を制限しているだけなので、
正規化した結果を簡約すること自体は可能です。

## α-変換

α-変換は束縛変数の名前を変更する処理です。
例えば以下の式を簡約してみます。

    (λx.λy.y x) (λx.y)
    
何も考えずに`x`を`λx.y`で置換すると以下のようになります。

    λy.y (λx.y)
    
元の式の最後にあった`y`は自由変数ですが、
置換後の式の最後にある`y`は束縛変数のように見えます。
この場合に以下のような式に変換するのが α-変換です。

    λz.z (λx.y)

このプログラムでは α-変換を実装していません。
α-変換を行わなくても簡約が正しく行われるようにしているためです。
このことを理解するためにはクラスの構成を見てみる必要があります。
このプログラムの簡単なクラス図は以下のようになっています。

![クラス図](ClassDiagram.png)

`Variable`は変数を表すインタフェースですが、
`BoundVariable`と`UnboundVariable`の二つの実装があります。
`BoundVariable`はいずれかのラムダ式に束縛されている束縛変数です。
自分自身を束縛している`Lambda`を参照しています。
`UnboundVariable`はどのラムダ式にも束縛されていない自由変数です。

例えば`λx.λy.x K`のインスタンスは以下のようになります。

![λx.λy.x K](x.y.xK.png)

インスタンス`x:BoundVariable`は自分が属するラムダ式への参照を持っています。
インスタンス`K:UnboundVariable`は
どこからも束縛されていないので`UnboundVariable`のインスタンスになります。

先の置換結果(`λy.y (λx.y)`)のインスタンスは以下のようになります。

![λy.y (λx.y)](y.yx.y.png)

同じ名前の変数`y`が`BoundVariable`と`UnboundVariable`に分類されていることがわかります。

この実装では簡約の途中で同名の束縛変数と自由変数が同じ文脈に出現しても
区別されるのでα-変換は不要となります。


## 制限事項

### Term#toString()

Term#toString()は式の文字列表現を返しますが、
正しくない表現を返す場合があります。
例えば以下の式を簡約してみます。

```
(λx y.y x) (λx.y)
```

末尾にある`y`は先頭のラムダ式とは無関係なので自由変数です。
簡約した結果は以下のようになります。

```
λy.y λx.y
```

最後の`y`はどう見ても束縛変数です。
ただし、これはTerm#toString()の問題で、
結果の式を正規化(Term#normalize())すると以下が得られます。

```
λ$0.$0 λ$1.y
```

最後の`y`は正しく自由変数として認識されていることがわかります。
本来であれば α-変換を行って

```
λz.z λx.y
```

のような結果を返すべきですが、
 α-変換を実装していないのでこのような結果になります。
単に表記の問題で簡約を行う上では支障はありません。